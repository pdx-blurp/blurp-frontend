var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import require$$0, { forwardRef, useRef, useState, useEffect } from "react";
import { Application } from "@splinetool/runtime";
function mergeRefs(refs) {
  return function(value) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = require$$0, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  g !== void 0 && (e = "" + g);
  a.key !== void 0 && (e = "" + a.key);
  a.ref !== void 0 && (h = a.ref);
  for (b in a)
    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      d[b] === void 0 && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const Spline = forwardRef((_a, ref) => {
  var _b = _a, {
    scene,
    style,
    onMouseDown,
    onMouseUp,
    onMouseHover,
    onKeyDown,
    onKeyUp,
    onStart,
    onLookAt,
    onFollow,
    onWheel,
    onLoad,
    renderOnDemand = true
  } = _b, props = __objRest(_b, [
    "scene",
    "style",
    "onMouseDown",
    "onMouseUp",
    "onMouseHover",
    "onKeyDown",
    "onKeyUp",
    "onStart",
    "onLookAt",
    "onFollow",
    "onWheel",
    "onLoad",
    "renderOnDemand"
  ]);
  const canvasRef = useRef(null);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    setIsLoading(true);
    let speApp;
    const events = [{
      name: "mouseDown",
      cb: onMouseDown
    }, {
      name: "mouseUp",
      cb: onMouseUp
    }, {
      name: "mouseHover",
      cb: onMouseHover
    }, {
      name: "keyDown",
      cb: onKeyDown
    }, {
      name: "keyUp",
      cb: onKeyUp
    }, {
      name: "start",
      cb: onStart
    }, {
      name: "lookAt",
      cb: onLookAt
    }, {
      name: "follow",
      cb: onFollow
    }, {
      name: "scroll",
      cb: onWheel
    }];
    if (canvasRef.current) {
      speApp = new Application(canvasRef.current, {
        renderOnDemand
      });
      async function init() {
        await speApp.load(scene);
        for (let event of events) {
          if (event.cb) {
            speApp.addEventListener(event.name, event.cb);
          }
        }
        setIsLoading(false);
        onLoad == null ? void 0 : onLoad(speApp);
      }
      init();
    }
    return () => {
      for (let event of events) {
        if (event.cb) {
          speApp.removeEventListener(event.name, event.cb);
        }
      }
      speApp.dispose();
    };
  }, [scene]);
  return /* @__PURE__ */ jsx("canvas", __spreadValues({
    ref: mergeRefs([ref, canvasRef]),
    style: __spreadValues({
      display: isLoading ? "none" : "block"
    }, style)
  }, props));
});
export { Spline as default };
